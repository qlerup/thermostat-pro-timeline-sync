name: Keep issues updated with latest release (Feature added / Bug fixed)

'on':
  issues:
    types: [opened, labeled, reopened]
  release:
    types: [published]
  schedule:
    - cron: '0 7 * * *'
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  update-comments:
    runs-on: ubuntu-latest
    steps:
      - name: Upsert comment(s)
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const LABELS = {
              feature: "Feature added",
              bug: "Bug fixed",
            };

            const MARKERS = {
              feature: "<!-- latest-release-feature-added -->",
              bug: "<!-- latest-release-bug-fixed -->",
            };

            function buildBody(type, version, url) {
              if (type === "feature") {
                return `${MARKERS.feature}
            ‚úÖ **Feature added** label detected.

            Latest release: **${version}**
            üîó ${url}`;
              }

              if (type === "bug") {
                return `${MARKERS.bug}
            üêõ **Bug fixed** label detected.

            Latest release: **${version}**
            üîó ${url}`;
              }

              throw new Error("Unknown comment type: " + type);
            }

            async function getLatestRelease() {
              const releases = await github.rest.repos.listReleases({
                owner,
                repo,
                per_page: 50,
              });

              return releases.data.find(r => !r.draft && !r.prerelease) || null;
            }

            async function upsert(issueNumber, type, body) {
              const marker = type === "feature" ? MARKERS.feature : MARKERS.bug;

              const comments = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: issueNumber,
                per_page: 100,
              });

              const existing = comments.data.find(c => (c.body || "").includes(marker));

              if (existing) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body,
                });
              }
            }

            async function handleIssue(issue, version, url) {
              if (issue.pull_request) return;

              const labelNames = (issue.labels || []).map(l => l.name);
              const hasFeature = labelNames.includes(LABELS.feature);
              const hasBug = labelNames.includes(LABELS.bug);

              if (hasFeature) {
                await upsert(issue.number, "feature", buildBody("feature", version, url));
              }
              if (hasBug) {
                await upsert(issue.number, "bug", buildBody("bug", version, url));
              }
            }

            const latest = await getLatestRelease();
            if (!latest) {
              core.warning("No non-draft, non-prerelease releases found.");
              return;
            }

            const version = latest.tag_name || latest.name || "unknown";
            const url = latest.html_url;

            // Issue event -> opdat√©r kun den issue
            if (context.eventName === "issues") {
              await handleIssue(context.payload.issue, version, url);
              return;
            }

            // Release/schedule/manual -> opdat√©r alle open issues med hver label (union)
            const featureIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: "open",
              labels: LABELS.feature,
              per_page: 100,
            });

            const bugIssues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: "open",
              labels: LABELS.bug,
              per_page: 100,
            });

            const combined = new Map();
            for (const it of [...featureIssues, ...bugIssues]) {
              if (!it.pull_request) combined.set(it.number, it);
            }

            for (const issue of combined.values()) {
              await handleIssue(issue, version, url);
            }

